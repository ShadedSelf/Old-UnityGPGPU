/*#pragma kernel Particler
#pragma kernel TrueLimits
#pragma kernel Clear
#pragma kernel Collision
#pragma kernel Find
#pragma kernel Lamb

#include "ComputeThings.cginc"

RWStructuredBuffer<Particle> particleBuffer;
RWStructuredBuffer<CollisionData> collisionBuffer;
RWStructuredBuffer<Grid> gridBuffer;
RWStructuredBuffer<Nei> neisBuffer;

StructuredBuffer<uint> keys;
StructuredBuffer<Cubes> cubes;

float deltaTime;
float antiMovement;
float rest;
float maxVelocity;
float time;
float radius;
float mass;
float mK;
float mQ;
float mE;

int particleCount;
int cubeCount;

float3 ext;
float3 gravity;
float3 worldSize;

float4x4 rot;

int3 gridSize;

[numthreads(128, 1, 1)]
void Particler(uint3 id : SV_DispatchThreadID)
{
	particleBuffer[id.x].vel.xyz = (particleBuffer[id.x].p.xyz - particleBuffer[id.x].pos.xyz) / deltaTime;

	/*float3 omega = 0;
	float3 velocityDiff = 0;
	float3 gradient = 0;
	for (int i = 0; i < neisBuffer[id.x].num; ++i)
	{
		velocityDiff = particleBuffer[id.x].vel.xyz - particleBuffer[neisBuffer[id.x].neis[i]].vel.xyz;
		gradient = WS(particleBuffer[id.x].p.xyz - particleBuffer[neisBuffer[id.x].neis[i]].p.xyz, antiMovement);
		omega += cross(velocityDiff, gradient);
	}

	float3 eta = 0;
	for (int ii = 0; ii < neisBuffer[id.x].num; ++ii)
	{
		eta += WS(particleBuffer[id.x].p.xyz - particleBuffer[neisBuffer[id.x].neis[ii]].p.xyz, antiMovement) * length(omega);
	}
	float3 n = normalize(eta);
	float3 end = cross(n, omega) * .0000001;
	end = (isnan(end)) ? 0 : end;

	particleBuffer[id.x].vel.xyz += end;*/
	/*particleBuffer[id.x].vel.xyz += gravity * deltaTime;
	//particleBuffer[id.x].vel.xyz += sin(normalizeFloat3(particleBuffer[id.x].pos.xyz, -gridSize, gridSize) * 3.14159 * 2) * gravity;
	particleBuffer[id.x].vel.xyz *= (length(particleBuffer[id.x].vel.xyz) > maxVelocity) ? maxVelocity / pow(length(particleBuffer[id.x].vel.xyz), 2) : .995;

	particleBuffer[id.x].pos.xyz = particleBuffer[id.x].p.xyz;
	particleBuffer[id.x].p.xyz = particleBuffer[id.x].pos.xyz + particleBuffer[id.x].vel.xyz * deltaTime;

	float3 aOne = normalizeFloat3(particleBuffer[id.x].p.xyz, -worldSize, worldSize);
	int3 gridTemp = clamp(floor(aOne * gridSize), 0, gridSize - 1);
	particleBuffer[id.x].vel.w = collisionBuffer[id.x].cell = fromGridToIndex((uint3)gridTemp, gridSize);
}

float map(float3 p)
{
	return max(sdBox(p, worldSize), -sdBox(mul((float3x3)rot, p - cubes[0].position), cubes[0].scale + radius));
}

float3 calcNormal(in float3 pos)
{
	const float2 eps = float2(0.00001, 0.0);
	float3 nor = float3(
		map(pos + eps.xyy).x - map(pos - eps.xyy).x,
		map(pos + eps.yxy).x - map(pos - eps.yxy).x,
		map(pos + eps.yyx).x - map(pos - eps.yyx).x);
	return normalize(nor);
}

[numthreads(128, 1, 1)]
void Lamb(uint3 id : SV_DispatchThreadID)
{
	float den = 0;
	float3 pet = (float3)0;
	float3 petI = (float3)0;
	float petsum = 0;
	float3 ot = 0;
	for (uint i = 0; i < neisBuffer[id.x].num; ++i)
	{
		ot = particleBuffer[neisBuffer[id.x].neis[i]].p.xyz;
		den += W(particleBuffer[id.x].p.xyz - ot, antiMovement);
		pet = WS(particleBuffer[id.x].p.xyz - ot, antiMovement) / rest;
		petsum += pow(length(pet), 2);
		petI += WS(particleBuffer[id.x].p.xyz - ot, antiMovement);
	}

	if (map(particleBuffer[id.x].p.xyz) >= -radius)
		den += rest / 4;

	petI /= rest;
	petsum += pow(length(petI), 2);
	petsum += mass;
	float l = den / rest - 1;
	float lambda = -l / petsum;
	particleBuffer[id.x].p.w = lambda;
}

[numthreads(128, 1, 1)]
void Collision(uint3 id : SV_DispatchThreadID)
{
	float3 dp = (float3)0;
	float4 ot = 0;
	for (uint i = 0; i < neisBuffer[id.x].num ; ++i)
	{
		ot = particleBuffer[neisBuffer[id.x].neis[i]].p;
		float co = -mK * pow(W(particleBuffer[id.x].p.xyz - ot.xyz, antiMovement) / W(antiMovement * mQ, antiMovement), mE);
		dp += (particleBuffer[id.x].p.w + ot.w + co) 
			* WS(particleBuffer[id.x].p.xyz - ot.xyz, antiMovement);
		//particleBuffer[id.x].vel.w = max(neisBuffer[id.x].num, neisBuffer[neisBuffer[i].num].num);
	}

	dp /= rest;
	dp -= calcNormal(particleBuffer[id.x].p.xyz) * max(map(particleBuffer[id.x].p.xyz), 0);

	particleBuffer[id.x].p.xyz += dp;
}

[numthreads(128, 1, 1)]
void Find(uint3 id : SV_DispatchThreadID)
{
	float3 aOne = normalizeFloat3(particleBuffer[id.x].p.xyz, -worldSize, worldSize);
	int3 gridTemp = clamp(floor(aOne * gridSize), 0, gridSize - 1);

	int num = 0;
	for (int x = -1; x < 2; ++x)
		for (int y = -1; y < 2; ++y)
			for (int z = -1; z < 2; ++z)
			{
				if (gridTemp.x + x > -1 && gridTemp.x + x < gridSize.x &&
					gridTemp.y + y > -1 && gridTemp.y + y < gridSize.y &&
					gridTemp.z + z > -1 && gridTemp.z + z < gridSize.z)
				{
					uint cell = fromGridToIndex((uint3)(gridTemp + int3(x, y, z)), gridSize);

					for (uint i = gridBuffer[cell].start; i < gridBuffer[cell].end; ++i)
					{
						uint pID = collisionBuffer[keys[i]].particleID;
						float3 grad = particleBuffer[id.x].p.xyz - particleBuffer[pID].p.xyz;
						float dist = length(grad);
						if (dist < antiMovement && id.x != pID)
						{
							if (num > 49) break;
							neisBuffer[id.x].neis[num] = pID;
							num++;
						}
					}
				}
			}

	neisBuffer[id.x].num = num;
}

[numthreads(128, 1, 1)]
void TrueLimits(uint3 id : SV_DispatchThreadID)
{
	uint cell = collisionBuffer[keys[id.x]].cell;

	if (collisionBuffer[keys[id.x - 1]].cell != cell)
		gridBuffer[cell].start = id.x;
	if (collisionBuffer[keys[id.x + 1]].cell != cell)
		gridBuffer[cell].end = id.x + 1;
}

[numthreads(128, 1, 1)]
void Clear(uint3 id : SV_DispatchThreadID)
{
	gridBuffer[id.x].start = 0;
	gridBuffer[id.x].end = 0;
}*/