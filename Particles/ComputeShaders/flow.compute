#pragma kernel Particler
#pragma kernel TrueLimits
#pragma kernel Clear
#pragma kernel Collision
#pragma kernel Find
#pragma kernel Lamb
#pragma kernel Swap
#pragma kernel Tmp

#include "ComputeThings.cginc"

RWStructuredBuffer<float4> pos;
RWStructuredBuffer<float4> p;
RWStructuredBuffer<float4> tmp;
RWStructuredBuffer<Particle> swapBuffer;
RWStructuredBuffer<CollisionData> collisionBuffer;
RWStructuredBuffer<Grid> gridBuffer;
RWStructuredBuffer<Nei> neisBuffer;

StructuredBuffer<Cubes> cubes;

//-- Globals: --
float deltaTime;
float particleRad;
float maxVelocity;
float time;

int particleCount;
int cubeCount;
int iterations;

float3 ext;
float3 gravity;
float3 worldSize;

int3 gridSize;

//-- Fluid: --
float rest;
float radius;
float ep;
float mK;
float mQ;
float mE;

float mapG(float3 p)
{
	return sdTorus(p, float2(3, 1));
}

float3 calcNormalG(in float3 pos)
{
	const float2 eps = float2(0.00001, 0.0);
	float3 nor = float3(
		mapG(pos + eps.xyy).x - mapG(pos - eps.xyy).x,
		mapG(pos + eps.yxy).x - mapG(pos - eps.yxy).x,
		mapG(pos + eps.yyx).x - mapG(pos - eps.yyx).x);
	return normalize(nor);
}

float map(float3 p)
{
	float d = sdBox(p, worldSize);
	for (int i = 0; i < cubeCount; i++)
		d = max(d, -sdBox(mul(cubes[i].rot, p - cubes[i].position.xyz), cubes[i].scale.xyz + radius));
	return d;
}

float3 calcNormal(in float3 pos)
{
	const float2 eps = float2(0.00001, 0.0);
	float3 nor = float3(
		map(pos + eps.xyy).x - map(pos - eps.xyy).x,
		map(pos + eps.yxy).x - map(pos - eps.yxy).x,
		map(pos + eps.yyx).x - map(pos - eps.yyx).x);
	return normalize(nor);
}

/*-- TODO: --*/ 
/* Try all this in spherical coordinates
/*-----------*/
[numthreads(32, 1, 1)]
void Particler (uint3 id : SV_DispatchThreadID)
{
	float3 vel = (p[id.x].xyz - pos[id.x].xyz) / deltaTime;

	float3 me = p[id.x].xyz;
	float3 vo = ZERO;
	for (uint i = 0; i < neisBuffer[id.x].num; ++i)
	{
		float3 ot = p[neisBuffer[id.x].neis[i]].xyz;
		float3 otpos = pos[neisBuffer[id.x].neis[i]].xyz;
		float3 otv = ot - otpos;

		vo += cross(otv - vel, WS(me - ot, particleRad));
		// float3 grad = WS(me - ot, particleRad) / rest; // * mass
		// gradient += dot(grad, grad);
		// density += W(me - ot, particleRad); // * mass
	}

	vel += gravity * deltaTime;
	// vel += -calcNormalG(p[id.x].xyz) * deltaTime * length(gravity);
	vel /= 1 + length(vel) * 0.005;

	pos[id.x].xyz = p[id.x].xyz;
	p[id.x].xyz = pos[id.x].xyz + vel * deltaTime;

	float3 aOne = normalizeFloat3(p[id.x].xyz, -worldSize, worldSize);
	int3 gridTemp = clamp(floor(aOne * gridSize), 0, gridSize - 1);
	collisionBuffer[id.x].cell = fromGridToIndex((uint3)gridTemp, gridSize);
	collisionBuffer[id.x].particleID = id.x;

	swapBuffer[id.x].pos = pos[id.x];
	swapBuffer[id.x].p = p[id.x];
}

[numthreads(32, 1, 1)]
void Swap(uint3 id : SV_DispatchThreadID)
{
	pos[id.x] = swapBuffer[collisionBuffer[id.x].particleID].pos;
	p[id.x] = swapBuffer[collisionBuffer[id.x].particleID].p;
	
	float3 aOne = normalizeFloat3(p[id.x].xyz, -worldSize, worldSize);
	int3 gridTemp = clamp(floor(aOne * gridSize), 0, gridSize - 1);
	uint cell = fromGridToIndex((uint3)gridTemp, gridSize);
	collisionBuffer[id.x].cell = cell;
	collisionBuffer[id.x].particleID = id.x;
}

[numthreads(32, 1, 1)]
void Lamb(uint3 id : SV_DispatchThreadID)
{
	float density = 0;
	float gradient = 0;
	float3 me = p[id.x].xyz;

	for (uint i = 0; i < neisBuffer[id.x].num; ++i)
	{
		float3 ot = p[neisBuffer[id.x].neis[i]].xyz;
		float3 grad = WS(me - ot, particleRad) / rest; // * mass
		gradient += dot(grad, grad);
		density += W(me - ot, particleRad); // * mass
	}
	// if (map(me) >= -radius)
	// 	density += rest / 4;
	
	float l = density / rest - 1; // = 0
	// l = max(l, 0);
	float lambda = -l / (gradient + ep);
	p[id.x].w = lambda;
}

[numthreads(32, 1, 1)]
void Collision(uint3 id : SV_DispatchThreadID)
{
	float3 dp = ZERO;
	float4 me = p[id.x];

	for (uint i = 0; i < neisBuffer[id.x].num ; ++i)
	{
		float4 ot = p[neisBuffer[id.x].neis[i]];
		float tmp = pow(W(me.xyz - ot.xyz, particleRad) / W(particleRad * mQ, particleRad), mE);
		float co = -mK * ((isnan(tmp)) ? 0.0 : tmp);
		dp += (me.w + ot.w + co) * WS(me.xyz - ot.xyz, particleRad); // * mass

		// if (distance(me.xyz, ot.xyz) < particleRad)
		// 	dp += (me.xyz - ot.xyz) * (1.0 - distance(me.xyz, ot.xyz) / particleRad);
	}
	dp /= rest;
	dp -= calcNormal(me.xyz) * max(map(me.xyz), 0) / iterations;
	tmp[id.x].xyz = dp;
}

[numthreads(32, 1, 1)]
void Tmp(uint3 id : SV_DispatchThreadID)
{
	p[id.x].xyz += tmp[id.x].xyz;
}

[numthreads(32, 1, 1)]
void Find(uint3 id : SV_DispatchThreadID)
{
	float3 me = p[id.x].xyz;
	float3 aOne = normalizeFloat3(me, -worldSize, worldSize);
	int3 gridTemp = clamp(floor(aOne * gridSize), 0, gridSize - 1);

	uint num = 0;
	for (int x = -1; x < 2; ++x)
	for (int y = -1; y < 2; ++y)
	for (int z = -1; z < 2; ++z)
		if (
		gridTemp.x + x > -1 && gridTemp.x + x < gridSize.x &&
		gridTemp.y + y > -1 && gridTemp.y + y < gridSize.y &&
		gridTemp.z + z > -1 && gridTemp.z + z < gridSize.z)
		{
			uint cell = fromGridToIndex((uint3)(gridTemp + int3(x, y, z)), gridSize);

			for (uint i = gridBuffer[cell].start; i < gridBuffer[cell].end; ++i)
			{
				if (num > 99) break;
				uint pID = collisionBuffer[i].particleID;
				if (distance(me, p[pID].xyz) < particleRad && id.x != pID)
				{
					neisBuffer[id.x].neis[num] = pID;
					num++;
				}
			}
		}

	neisBuffer[id.x].num = num;
}

[numthreads(32, 1, 1)]
void TrueLimits(uint3 id : SV_DispatchThreadID)
{
	uint cell = collisionBuffer[id.x].cell;

	if (collisionBuffer[max(id.x - 1, 0)].cell != cell) //max
		gridBuffer[cell].start = id.x;
	if (collisionBuffer[id.x + 1].cell != cell) //y no min
		gridBuffer[cell].end = id.x + 1;
}

[numthreads(32, 1, 1)]
void Clear(uint3 id : SV_DispatchThreadID)
{
	gridBuffer[id.x].start = 0;
	gridBuffer[id.x].end = 0;
}
