
#pragma kernel CSMain
#include "RayThings.cginc"

RWTexture2D<float4> Result;

float s;
float3 eye;
float3 up;
float3 right;
float3 fw;

float3 _LightDir;
float _L;

float2 angle;

int maxSteps;
float drawDist;
float epSI;

float fwMult;
float projectionMult;

float minT;
float maxT;
float kk;
float _Time;

int2 pixel;
int texSize;

float map(float3 p)
{
	/*float3 Scale = float3(3, 2, 2);
	float3 Offset = float3(2, 2, 2);

	float r;
	int n = 0;
	while (n < 10) {
		if (p.x + p.y<0) p.xy = -p.yx; // fold 1
		if (p.x + p.z<0) p.xz = -p.zx; // fold 2
		if (p.y + p.z<0) p.zy = -p.yz; // fold 3	
		p = p*Scale - Offset*(Scale - 1.0);
		n++;
	}
	return (length(p)) * pow(Scale, -float(n));*/

	float Power = 6 + minT;

	float3 z = p;
	float dr = 1.0;
	float r = 0.0;
	for (int i = 0; i < 5; i++) {
		r = length(z);
		if (r>10) break;

		// convert to polar coordinates
		float theta = acos(z.z / r) + _Time / 10;
		float phi = atan2(z.y, z.x);
		dr = pow(r, Power - 1.0)*Power*dr + 1.0;

		// scale and rotate the point
		float zr = pow(r, Power);
		theta = theta*Power;
		phi = phi*Power;

		// convert back to cartesian coordinates
		z = zr*float3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
		z += p;
	}
	return 0.5*log(r)*r / dr;
}

float shadow(float3 ro, float3 rd, float mint, float maxt)
{
	for (float t = mint; t < maxt;)
	{
		float h = map(ro + rd * t);
		if (h < 0.001)
			return 0.0;
		t += h;
	}
	return 1;
}

float3 calcNormal(in float3 pos)
{
	const float2 eps = float2(0.00001, 0.0);
	float3 nor = float3(
		map(pos + eps.xyy).x - map(pos - eps.xyy).x,
		map(pos + eps.yxy).x - map(pos - eps.yxy).x,
		map(pos + eps.yyx).x - map(pos - eps.yyx).x);
	return normalize(nor);
}

float getCols(float3 normal)
{
	float doter = dot(-_LightDir.xyz, normal);

	float color = doter * .5 + .5;
	return color + (1 - color) * _L;
}


float shade(float3 p)
{
	float ret = 1;

	float3 n = calcNormal(p);
	//float s = shadow(p, -_LightDir, minT, maxT);

	//float doter = dot(-_LightDir.xyz, n);

	ret = getCols(n);
	/*if (pixel.x % 2 == 0 && pixel.y % 2 == 0 && s < .5 && doter > .001 || (pixel.x % 2 == 0 && pixel.y % 2 == 0 && doter < 0))
	ret = lerp(0, .5 + _L / 2, 1 - abs(doter));*/

	return ret;
}

float4 raymarch(float3 ro, float3 rd, float s)
{
	float t = 0;
	float3 p = ro + rd * t;
	float4 ret = 0;
	float3 aro = ro;
	float3 ard = rd;
	for (int i = 0; i < maxSteps; ++i)
	{
		if (t >= s || t > drawDist)
		{
			return ret;
		}
		p = aro;
		float d = map(p);
		if (d < epSI) //larger eps at larger depth?=
		{
			ret = 1 - (float)i / maxSteps * (maxSteps / 150.0) * 2;
			//ret = shade(p.xyz);
			return ret;
		}
		t += d;
		aro = aro + ard * d;
		float dis = distance(ro, aro);
	}
	return ret;
}

[numthreads(32, 32, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	s = 1000;
	pixel = id.xy;

	float x = ((float)id.x / texSize - .5) * projectionMult;
	float y = ((float)id.y / texSize - .5) * projectionMult;

	float3 ro = (right * x + up * y) + eye + fw * fwMult;
	float3 rd = normalize(ro - eye);

	float4 temp = raymarch(ro, rd, s);

	Result[id.xy] = float4((float3)temp.w, 1);
}

